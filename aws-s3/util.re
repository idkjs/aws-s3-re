/*{{{
 * Copyright (C) 2015 Trevor Smith <trevorsummerssmith@gmail.com>
 * Copyright (C) 2018 Anders Fugmann <anders@fugmann.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
  }}}*/
open StdLabels;

/* @see https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-streaming.html
      public static String UriEncode(CharSequence input, boolean encodeSlash) {
             StringBuilder result = new StringBuilder();
             for (int i = 0; i < input.length(); i++) {
                 char ch = input.charAt(i);
                 if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9') || ch == '_' || ch == '-' || ch == '~' || ch == '.') {
                     result.append(ch);
                 } else if (ch == '/') {
                     result.append(encodeSlash ? "%2F" : ch);
                 } else {
                     result.append(toHexUTF8(ch));
                 }
             }
             return result.toString();
         }
   */
let encode_string = s => {
  /* Percent encode the path as s3 wants it. Uri doesn't
     encode $, or the other sep characters in a path.
     If upstream allows that we can nix this function */
  let n = String.length(s);
  let buf = Buffer.create(n * 3);
  for (i in 0 to n - 1) {
    let c = s.[i];
    switch (c) {
    | 'a'..'z'
    | 'A'..'Z'
    | '0'..'9'
    | '_'
    | '-'
    | '~'
    | '.'
    | '/' => Buffer.add_char(buf, c)
    | '%' =>
      /* Sigh. Annoying we're expecting already escaped strings so ignore the escapes */

      let is_hex = (
        fun
        | 'a'..'f'
        | 'A'..'F'
        | '0'..'9' => true
        | _ => false
      );

      if (i + 2 < n) {
        if (is_hex(s.[i + 1]) && is_hex(s.[i + 2])) {
          Buffer.add_char(buf, c);
        } else {
          Buffer.add_string(buf, "%25");
        };
      };
    | _ => Buffer.add_string(buf, Printf.sprintf("%%%X", Char.code(c)))
    };
  };
  Buffer.contents(buf);
};
