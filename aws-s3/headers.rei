type key = string;
type t('a);
let empty: t('a);
let is_empty: t('a) => bool;
let mem: (key, t('a)) => bool;
let singleton: (key, 'a) => t('a);
let remove: (key, t('a)) => t('a);
let merge:
  ((key, option('a), option('b)) => option('c), t('a), t('b)) => t('c);
let union: ((key, 'a, 'a) => option('a), t('a), t('a)) => t('a);
let compare: (('a, 'a) => int, t('a), t('a)) => int;
let equal: (('a, 'a) => bool, t('a), t('a)) => bool;
let iter: ((key, 'a) => unit, t('a)) => unit;
let fold: ((key, 'a, 'b) => 'b, t('a), 'b) => 'b;
let for_all: ((key, 'a) => bool, t('a)) => bool;
let exists: ((key, 'a) => bool, t('a)) => bool;
let filter: ((key, 'a) => bool, t('a)) => t('a);
let partition: ((key, 'a) => bool, t('a)) => (t('a), t('a));
let cardinal: t('a) => int;
let bindings: t('a) => list((key, 'a));
let find: (key, t('a)) => 'a;
let find_opt: (key, t('a)) => option('a);
let find_first: (key => bool, t('a)) => (key, 'a);
let find_first_opt: (key => bool, t('a)) => option((key, 'a));
let find_last: (key => bool, t('a)) => (key, 'a);
let find_last_opt: (key => bool, t('a)) => option((key, 'a));
let map: ('a => 'b, t('a)) => t('b);
let mapi: ((key, 'a) => 'b, t('a)) => t('b);
let change: (~key: key, ~f: option('a) => option('a), t('a)) => t('a);
let add: (~key: key, ~value: 'a, t('a)) => t('a);
let add_opt: (~key: key, ~value: option('a), t('a)) => t('a);
